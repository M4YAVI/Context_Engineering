 Here is the documentation rewritten to be exceptionally clear, structured, and unambiguous, designed specifically for a Large Language Model to understand and use for code generation.

The key changes focus on:
*   **Explicit Instructions:** Using direct, command-like language.
*   **Complete Code Blocks:** Providing full, self-contained, and commented code examples that can be used directly.
*   **Logical Structure:** Organizing information into a step-by-step, hierarchical format that is easy to parse.
*   **Clarity on Environment/Modes:** Explicitly stating which features work in which modes (standalone, Next.js, Express) to prevent errors.
*   **Context and Purpose:** Explaining *why* a component exists, not just *what* it is.

---

### **xmcp: A Guide for AI-Powered Development**

This document provides a complete and unambiguous specification for the `xmcp` framework. Follow these instructions precisely to build, configure, and deploy Model Context Protocol (MCP) applications.

### **1. Core Concepts**

`xmcp` is a TypeScript framework for creating servers that expose "tools" to AI models via the Model Context Protocol (MCP).

There are two primary deployment methods, called **transports**:

1.  **HTTP Transport**: Deploys the server as a web service accessible via a URL. This is for tools that need to run on a server, like database queries or API calls. It is stateless.
2.  **STDIO Transport**: Deploys the server as a local command-line process. This is for tools that need to operate on the local machine, like file system operations.

You can enable one or both transports in your configuration.

### **2. Getting Started: Project Setup**

You have three options for setting up an `xmcp` project. Choose one.

#### **Option A: Create a New Standalone Project (Recommended)**

This is the simplest method. It scaffolds a complete, ready-to-run `xmcp` application.

1.  Open your terminal and run this command:
    ```bash
    npx create-xmcp-app@latest
    ```
2.  The CLI will ask for a `project name`.
3.  You will be guided through prompts to configure the project.

#### **Option B: Integrate with an Existing Next.js Project**

Use this to add `xmcp` tools to your Next.js application. See Section 9 for detailed instructions.

#### **Option C: Integrate with an Existing Express Project**

Use this to add `xmcp` tools to your Express.js application. See Section 10 for detailed instructions.

### **3. Project Structure**

A standard `xmcp` project generated by `create-xmcp-app` has the following file structure:

```
my-project/
├── src/
│   ├── middleware.ts   # (Optional) For HTTP server request/response processing.
│   └── tools/          # All your tool definitions go here. xmcp auto-discovers them.
│       ├── greet.ts
│       └── search.ts
├── dist/               # Final built output is generated here. Do not edit.
├── package.json        # Project dependencies and scripts.
├── tsconfig.json       # TypeScript configuration.
└── xmcp.config.ts       # Main configuration file for the xmcp framework.
```

### **4. Creating Tools**

Tools are the core of `xmcp`. They are functions that an AI model can call.

**Rule:** To create a tool, you must create a new `.ts` file inside the `src/tools/` directory.

Each tool file **must** export exactly three items:
1.  `schema`: A Zod object defining the tool's input parameters.
2.  `metadata`: An object containing the tool's name, description, and other hints.
3.  A `default` export: An `async` function that contains the tool's logic.

#### **Example: A Complete `greet` Tool**

Create a file at `src/tools/greet.ts` with the following content:

```typescript
// File: src/tools/greet.ts

import { z } from "zod";
import { type InferSchema } from "xmcp";

// 1. Define the input schema using Zod.
// Each key is a parameter name.
// The Zod type enforces validation.
// The .describe() string is crucial for the AI to understand the parameter.
export const schema = {
  name: z.string().describe("The name of the person to greet."),
};

// 2. Define the tool's metadata.
export const metadata = {
  // A unique machine-readable name for the tool. Use kebab-case or snake_case.
  name: "greet",
  // A human-readable description of what the tool does.
  description: "Greets a person by their name.",
  // Annotations provide hints to the client/AI.
  annotations: {
    title: "Greet User",      // A friendly display name for UIs.
    readOnlyHint: true,       // True if the tool does not change any state.
    destructiveHint: false,   // True if the tool performs an irreversible action (e.g., delete a file).
    idempotentHint: true,     // True if calling the tool multiple times with the same input yields the same result.
  },
};

// 3. Implement the tool's logic as a default export.
// The function's argument is automatically typed from the schema using InferSchema.
export default async function greet({ name }: InferSchema<typeof schema>) {
  // Perform the tool's action.
  const result = `Hello, ${name}! Welcome to the world of xmcp.`;

  // The function must return an object with a `content` array.
  // Each item in the array is a piece of content to return to the AI.
  // The most common type is "text".
  return {
    content: [{ type: "text", text: result }],
  };
}
```

### **5. Development and Building**

The `package.json` file created by `create-xmcp-app` includes the necessary scripts.

*   **Start the development server:**
    This server watches for file changes and reloads automatically (hot-reloading).
    ```bash
    npm run dev
    ```

*   **Build the project for production:**
    This bundles your code and places it in the `dist/` directory.
    ```bash
    npm run build
    ```

*   **Run the production server (HTTP):**
    ```bash
    node dist/http.js
    ```

*   **Run the production server (STDIO):**
    ```bash
    node dist/stdio.js
    ```

### **6. Configuration (`xmcp.config.ts`)**

You control the behavior of `xmcp` by editing the `xmcp.config.ts` file in your project's root.

#### **Example: Basic Configuration**
This configuration enables both HTTP and STDIO transports.

```typescript
// File: xmcp.config.ts

import { type XmcpConfig } from "xmcp";

const config: XmcpConfig = {
  // Set to `true` to build the HTTP server (dist/http.js)
  http: true,
  // Set to `true` to build the STDIO server (dist/stdio.js)
  stdio: true,
};

export default config;
```

#### **Customizing the Tools Directory**

```typescript
// File: xmcp.config.ts

import { type XmcpConfig } from "xmcp";

const config: XmcpConfig = {
  tools: {
    // xmcp will discover tools in this directory instead of 'src/tools'
    directory: "source/my-tools",
  },
};

export default config;
```

#### **Customizing the HTTP Server**

```typescript
// File: xmcp.config.ts

import { type XmcpConfig } from "xmcp";

const config: XmcpConfig = {
  http: {
    // Port the server will listen on.
    port: 3002,
    // The endpoint path for the MCP server.
    endpoint: "/mcp",
    // Optional CORS configuration.
    cors: {
      origin: "https://my-app.com",
      methods: ["GET", "POST"],
    },
  },
};

export default config;
```

### **7. Middleware and Authentication (HTTP Only)**

Middleware allows you to process requests before they reach your tools. This is ideal for authentication.

**To use middleware, create a file at `src/middleware.ts`.** This file is only used when building the standalone HTTP server.

#### **Example: API Key Authentication**

`xmcp` provides a built-in middleware for API key validation.

```typescript
// File: src/middleware.ts

import { apiKeyAuthMiddleware, type Middleware } from "xmcp";

// This middleware checks for an 'x-api-key' header.
const middleware: Middleware = apiKeyAuthMiddleware({
  // The name of the HTTP header containing the key.
  headerName: "x-api-key",
  // A function that returns `true` if the key is valid.
  // This can be an async function to check a database.
  validateApiKey: async (apiKey) => {
    // In a real application, securely compare this key.
    // e.g., const isValid = await db.apiKeys.find(apiKey);
    return apiKey === "my-secret-api-key-123";
  },
});

export default middleware;
```

#### **Accessing Headers in Tools (`xmcp/headers`)**

In **standalone HTTP mode only**, you can access request headers from within your tool's logic.

```typescript
// File: src/tools/search.ts

import { headers } from "xmcp/headers";
import { z } from "zod";
import { type InferSchema } from "xmcp";

export const schema = {
  query: z.string().describe("The search query."),
};

export const metadata = {
  name: "external-search",
  description: "Search an external service using an API key from headers.",
};

export default async function search({ query }: InferSchema<typeof schema>) {
  // headers() returns the incoming request headers.
  const requestHeaders = headers();
  const apiKey = requestHeaders["x-api-key"]; // Access a specific header.

  if (!apiKey) {
    return { content: [{ type: "text", text: "Error: API key is missing." }] };
  }

  // Use the apiKey to make an external API call.
  // const response = await fetch(`https://api.example.com/search?q=${query}`, {
  //   headers: { 'Authorization': `Bearer ${apiKey}` }
  // });
  // const data = await response.json();

  const data = { results: [`Result for '${query}' using key ending in ...${(apiKey as string).slice(-4)}`] };

  return {
    content: [{ type: "text", text: JSON.stringify(data) }],
  };
}
```

### **8. Vercel Deployment**

To deploy a standalone `xmcp` HTTP server to Vercel:

1.  **Build for Vercel:** Run the build command with the `--vercel` flag. This creates a `.vercel` output directory compatible with Vercel's build output API.
    ```bash
    npx xmcp build --vercel
    ```

2.  **Deploy to Vercel:** Use the Vercel CLI to deploy the prebuilt output.
    ```bash
    vercel deploy --prod --prebuilt
    ```

You can also add a `vercel.json` file to your project root to automate the build command on Vercel's platform.
```json
{
  "$schema": "https://openapi.vercel.sh/vercel.json",
  "buildCommand": "npx xmcp build --vercel"
}
```

### **9. Usage with Next.js (Experimental Adapter)**

Follow these steps to integrate `xmcp` into an existing Next.js App Router project.

1.  **Initialize `xmcp`:** In the root of your Next.js project, run:
    ```bash
    npx init-xmcp@latest
    ```
    This will create `xmcp.config.ts` and a `tools` directory for you.

2.  **Update `package.json` scripts:** Modify your `scripts` to run `xmcp` alongside Next.js.
    ```json
    {
      "scripts": {
        "dev": "xmcp dev & next dev",
        "build": "xmcp build && next build",
        "start": "next start"
      }
    }
    ```

3.  **Create the API Route:** Create a new route handler file at `src/app/mcp/route.ts` (or your preferred path). This file connects `xmcp` to Next.js.

    ```typescript
    // File: src/app/mcp/route.ts

    import { xmcpHandler } from "@xmcp/adapter";

    // This exports the handler for both GET and POST requests.
    export { xmcpHandler as GET, xmcpHandler as POST };
    ```
    Your MCP endpoint will now be available at `http://localhost:3000/mcp`.

**Important Notes for Next.js Adapter Mode:**
*   The `src/middleware.ts` file is **not** used. Use Next.js Middleware instead.
*   The `xmcp/headers` module is **not** supported. Use `next/headers` to access request headers.
*   Configure the HTTP server (port, etc.) through Next.js, not `xmcp.config.ts`.

### **10. Usage with Express (Experimental Adapter)**

Follow these steps to integrate `xmcp` into an existing Express project.

1.  **Initialize `xmcp`:** In the root of your Express project, run:
    ```bash
    npx init-xmcp@latest
    ```

2.  **Update `package.json` scripts:**
    ```json
    {
      "scripts": {
        "dev": "xmcp dev & ts-node-dev src/server.ts", // Replace with your existing dev command
        "build": "xmcp build && tsc" // Replace with your existing build command
      }
    }
    ```
    When you run `build`, `xmcp` creates a bundled adapter file in a `.xmcp/adapter` directory.

3.  **Add the Endpoint to Your Express App:** Import and use the `xmcpHandler` in your main Express server file.

    ```typescript
    // File: src/server.ts (or your main Express file)

    import express from 'express';
    // Import the handler from the generated adapter file.
    import { xmcpHandler } from "../.xmcp/adapter";

    const app = express();
    const port = 3000;

    // Your other routes...
    app.get('/', (req, res) => {
      res.send('Hello from Express!');
    });

    // Add the xmcp handler to the /mcp endpoint.
    app.get("/mcp", xmcpHandler);
    app.post("/mcp", xmcpHandler);

    app.listen(port, () => {
      console.log(`Server listening at http://localhost:${port}`);
    });
    ```

**Important Notes for Express Adapter Mode:**
*   The `src/middleware.ts` file is **not** used. Use standard Express middleware on the `/mcp` route instead.
*   The `xmcp/headers` module is **not** supported. Access headers via the `req.headers` object in your Express middleware.
